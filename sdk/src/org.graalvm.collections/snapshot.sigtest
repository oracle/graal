#Signature file v4.1
#Version 

CLSS public abstract interface java.io.Serializable

CLSS public abstract interface java.lang.Iterable<%0 extends java.lang.Object>
meth public abstract java.util.Iterator<{java.lang.Iterable%0}> iterator()
meth public java.util.Spliterator<{java.lang.Iterable%0}> spliterator()
meth public void forEach(java.util.function.Consumer<? super {java.lang.Iterable%0}>)

CLSS public abstract java.lang.Number
cons public init()
intf java.io.Serializable
meth public abstract double doubleValue()
meth public abstract float floatValue()
meth public abstract int intValue()
meth public abstract long longValue()
meth public byte byteValue()
meth public short shortValue()
supr java.lang.Object
hfds serialVersionUID

CLSS public java.lang.Object
cons public init()
meth protected java.lang.Object clone() throws java.lang.CloneNotSupportedException
meth protected void finalize() throws java.lang.Throwable
 anno 0 java.lang.Deprecated(boolean forRemoval=true, java.lang.String since="9")
meth public boolean equals(java.lang.Object)
meth public final java.lang.Class<?> getClass()
meth public final void notify()
meth public final void notifyAll()
meth public final void wait() throws java.lang.InterruptedException
meth public final void wait(long) throws java.lang.InterruptedException
meth public final void wait(long,int) throws java.lang.InterruptedException
meth public int hashCode()
meth public java.lang.String toString()

CLSS public java.util.concurrent.atomic.AtomicLong
cons public init()
cons public init(long)
intf java.io.Serializable
meth public double doubleValue()
meth public final boolean compareAndSet(long,long)
meth public final boolean weakCompareAndSet(long,long)
 anno 0 java.lang.Deprecated(boolean forRemoval=false, java.lang.String since="9")
meth public final boolean weakCompareAndSetAcquire(long,long)
meth public final boolean weakCompareAndSetPlain(long,long)
meth public final boolean weakCompareAndSetRelease(long,long)
meth public final boolean weakCompareAndSetVolatile(long,long)
meth public final long accumulateAndGet(long,java.util.function.LongBinaryOperator)
meth public final long addAndGet(long)
meth public final long compareAndExchange(long,long)
meth public final long compareAndExchangeAcquire(long,long)
meth public final long compareAndExchangeRelease(long,long)
meth public final long decrementAndGet()
meth public final long get()
meth public final long getAcquire()
meth public final long getAndAccumulate(long,java.util.function.LongBinaryOperator)
meth public final long getAndAdd(long)
meth public final long getAndDecrement()
meth public final long getAndIncrement()
meth public final long getAndSet(long)
meth public final long getAndUpdate(java.util.function.LongUnaryOperator)
meth public final long getOpaque()
meth public final long getPlain()
meth public final long incrementAndGet()
meth public final long updateAndGet(java.util.function.LongUnaryOperator)
meth public final void lazySet(long)
meth public final void set(long)
meth public final void setOpaque(long)
meth public final void setPlain(long)
meth public final void setRelease(long)
meth public float floatValue()
meth public int intValue()
meth public java.lang.String toString()
meth public long longValue()
supr java.lang.Number
hfds U,VALUE,VM_SUPPORTS_LONG_CAS,serialVersionUID,value

CLSS public abstract interface org.graalvm.collections.EconomicMap<%0 extends java.lang.Object, %1 extends java.lang.Object>
intf org.graalvm.collections.UnmodifiableEconomicMap<{org.graalvm.collections.EconomicMap%0},{org.graalvm.collections.EconomicMap%1}>
meth public abstract org.graalvm.collections.MapCursor<{org.graalvm.collections.EconomicMap%0},{org.graalvm.collections.EconomicMap%1}> getEntries()
meth public abstract void clear()
meth public abstract void replaceAll(java.util.function.BiFunction<? super {org.graalvm.collections.EconomicMap%0},? super {org.graalvm.collections.EconomicMap%1},? extends {org.graalvm.collections.EconomicMap%1}>)
meth public abstract {org.graalvm.collections.EconomicMap%1} put({org.graalvm.collections.EconomicMap%0},{org.graalvm.collections.EconomicMap%1})
meth public abstract {org.graalvm.collections.EconomicMap%1} removeKey({org.graalvm.collections.EconomicMap%0})
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> create()
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> create(int)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> create(org.graalvm.collections.Equivalence)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> create(org.graalvm.collections.Equivalence,int)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> create(org.graalvm.collections.Equivalence,org.graalvm.collections.UnmodifiableEconomicMap<{%%0},{%%1}>)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> create(org.graalvm.collections.UnmodifiableEconomicMap<{%%0},{%%1}>)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> emptyMap()
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> of({%%0},{%%1})
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> of({%%0},{%%1},{%%0},{%%1})
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicMap<{%%0},{%%1}> wrapMap(java.util.Map<{%%0},{%%1}>)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.MapCursor<{%%0},{%%1}> emptyCursor()
meth public void putAll(org.graalvm.collections.EconomicMap<{org.graalvm.collections.EconomicMap%0},{org.graalvm.collections.EconomicMap%1}>)
meth public void putAll(org.graalvm.collections.UnmodifiableEconomicMap<? extends {org.graalvm.collections.EconomicMap%0},? extends {org.graalvm.collections.EconomicMap%1}>)
meth public {org.graalvm.collections.EconomicMap%1} putIfAbsent({org.graalvm.collections.EconomicMap%0},{org.graalvm.collections.EconomicMap%1})

CLSS public final org.graalvm.collections.EconomicMapUtil
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> boolean equals(org.graalvm.collections.UnmodifiableEconomicMap<{%%0},{%%1}>,org.graalvm.collections.UnmodifiableEconomicMap<{%%0},{%%1}>)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> int hashCode(org.graalvm.collections.UnmodifiableEconomicMap<{%%0},{%%1}>)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> java.util.Comparator<org.graalvm.collections.UnmodifiableEconomicMap<{%%0},{%%1}>> lexicographicalComparator(java.util.Comparator<{%%0}>,java.util.Comparator<{%%1}>)
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.EconomicSet<{%%0}> keySet(org.graalvm.collections.EconomicMap<{%%0},{%%1}>)
supr java.lang.Object

CLSS public org.graalvm.collections.EconomicMapWrap<%0 extends java.lang.Object, %1 extends java.lang.Object>
cons public init(java.util.Map<{org.graalvm.collections.EconomicMapWrap%0},{org.graalvm.collections.EconomicMapWrap%1}>)
intf org.graalvm.collections.EconomicMap<{org.graalvm.collections.EconomicMapWrap%0},{org.graalvm.collections.EconomicMapWrap%1}>
meth public boolean containsKey({org.graalvm.collections.EconomicMapWrap%0})
meth public boolean isEmpty()
meth public int size()
meth public java.lang.Iterable<{org.graalvm.collections.EconomicMapWrap%0}> getKeys()
meth public java.lang.Iterable<{org.graalvm.collections.EconomicMapWrap%1}> getValues()
meth public java.lang.String toString()
meth public org.graalvm.collections.MapCursor<{org.graalvm.collections.EconomicMapWrap%0},{org.graalvm.collections.EconomicMapWrap%1}> getEntries()
meth public void clear()
meth public void replaceAll(java.util.function.BiFunction<? super {org.graalvm.collections.EconomicMapWrap%0},? super {org.graalvm.collections.EconomicMapWrap%1},? extends {org.graalvm.collections.EconomicMapWrap%1}>)
meth public {org.graalvm.collections.EconomicMapWrap%1} get({org.graalvm.collections.EconomicMapWrap%0})
meth public {org.graalvm.collections.EconomicMapWrap%1} put({org.graalvm.collections.EconomicMapWrap%0},{org.graalvm.collections.EconomicMapWrap%1})
meth public {org.graalvm.collections.EconomicMapWrap%1} putIfAbsent({org.graalvm.collections.EconomicMapWrap%0},{org.graalvm.collections.EconomicMapWrap%1})
meth public {org.graalvm.collections.EconomicMapWrap%1} removeKey({org.graalvm.collections.EconomicMapWrap%0})
supr java.lang.Object
hfds map

CLSS public abstract interface org.graalvm.collections.EconomicSet<%0 extends java.lang.Object>
intf org.graalvm.collections.UnmodifiableEconomicSet<{org.graalvm.collections.EconomicSet%0}>
meth public abstract boolean add({org.graalvm.collections.EconomicSet%0})
meth public abstract void clear()
meth public abstract void remove({org.graalvm.collections.EconomicSet%0})
meth public static <%0 extends java.lang.Object> org.graalvm.collections.EconomicSet<{%%0}> create()
meth public static <%0 extends java.lang.Object> org.graalvm.collections.EconomicSet<{%%0}> create(int)
meth public static <%0 extends java.lang.Object> org.graalvm.collections.EconomicSet<{%%0}> create(org.graalvm.collections.Equivalence)
meth public static <%0 extends java.lang.Object> org.graalvm.collections.EconomicSet<{%%0}> create(org.graalvm.collections.Equivalence,int)
meth public static <%0 extends java.lang.Object> org.graalvm.collections.EconomicSet<{%%0}> create(org.graalvm.collections.Equivalence,org.graalvm.collections.UnmodifiableEconomicSet<{%%0}>)
meth public static <%0 extends java.lang.Object> org.graalvm.collections.EconomicSet<{%%0}> create(org.graalvm.collections.UnmodifiableEconomicSet<{%%0}>)
meth public void addAll(java.lang.Iterable<{org.graalvm.collections.EconomicSet%0}>)
meth public void addAll(java.util.Iterator<{org.graalvm.collections.EconomicSet%0}>)
meth public void addAll(org.graalvm.collections.EconomicSet<{org.graalvm.collections.EconomicSet%0}>)
meth public void removeAll(java.lang.Iterable<{org.graalvm.collections.EconomicSet%0}>)
meth public void removeAll(java.util.Iterator<{org.graalvm.collections.EconomicSet%0}>)
meth public void removeAll(org.graalvm.collections.EconomicSet<{org.graalvm.collections.EconomicSet%0}>)
meth public void retainAll(org.graalvm.collections.EconomicSet<{org.graalvm.collections.EconomicSet%0}>)

CLSS public abstract org.graalvm.collections.Equivalence
cons protected init()
fld public final static org.graalvm.collections.Equivalence DEFAULT
fld public final static org.graalvm.collections.Equivalence IDENTITY
fld public final static org.graalvm.collections.Equivalence IDENTITY_WITH_SYSTEM_HASHCODE
meth public abstract boolean equals(java.lang.Object,java.lang.Object)
meth public abstract int hashCode(java.lang.Object)
supr java.lang.Object

CLSS public org.graalvm.collections.LockFreePool<%0 extends java.lang.Object>
cons public init()
meth public void add({org.graalvm.collections.LockFreePool%0})
meth public {org.graalvm.collections.LockFreePool%0} get()
supr java.lang.Object
hfds head
hcls Node

CLSS public org.graalvm.collections.LockFreePrefixTree
cons public init(org.graalvm.collections.LockFreePrefixTree$Allocator)
innr public abstract static Allocator
innr public static HeapAllocator
innr public static Node
innr public static ObjectPoolingAllocator
meth public <%0 extends java.lang.Object> void topDown({%%0},java.util.function.BiFunction<{%%0},java.lang.Long,{%%0}>,java.util.function.BiConsumer<{%%0},java.lang.Long>)
meth public org.graalvm.collections.LockFreePrefixTree$Allocator allocator()
meth public org.graalvm.collections.LockFreePrefixTree$Node root()
meth public void reset()
supr java.lang.Object
hfds allocator,root
hcls FailedAllocationException

CLSS public abstract static org.graalvm.collections.LockFreePrefixTree$Allocator
 outer org.graalvm.collections.LockFreePrefixTree
cons public init()
meth public abstract java.util.concurrent.atomic.AtomicReferenceArray newHashChildren(int)
meth public abstract java.util.concurrent.atomic.AtomicReferenceArray newLinearChildren(int)
meth public abstract org.graalvm.collections.LockFreePrefixTree$Node newNode(long)
meth public abstract void shutdown()
supr java.lang.Object

CLSS public static org.graalvm.collections.LockFreePrefixTree$HeapAllocator
 outer org.graalvm.collections.LockFreePrefixTree
cons public init()
meth public java.util.concurrent.atomic.AtomicReferenceArray newHashChildren(int)
meth public java.util.concurrent.atomic.AtomicReferenceArray newLinearChildren(int)
meth public org.graalvm.collections.LockFreePrefixTree$Node newNode(long)
meth public void shutdown()
supr org.graalvm.collections.LockFreePrefixTree$Allocator

CLSS public static org.graalvm.collections.LockFreePrefixTree$Node
 outer org.graalvm.collections.LockFreePrefixTree
meth public java.lang.String toString()
meth public long bitwiseOrValue(long)
meth public long incValue()
meth public long value()
meth public org.graalvm.collections.LockFreePrefixTree$Node at(org.graalvm.collections.LockFreePrefixTree$Allocator,long)
meth public void setValue(long)
supr java.util.concurrent.atomic.AtomicLong
hfds CHILDREN_UPDATER,FROZEN_NODE,INITIAL_HASH_NODE_SIZE,INITIAL_LINEAR_NODE_SIZE,MAX_HASH_SKIPS,MAX_LINEAR_NODE_SIZE,children,key,serialVersionUID
hcls FrozenNode,HashChildren,LinearChildren

CLSS public static org.graalvm.collections.LockFreePrefixTree$ObjectPoolingAllocator
 outer org.graalvm.collections.LockFreePrefixTree
cons public init()
cons public init(int)
meth public java.lang.String status()
meth public java.util.concurrent.atomic.AtomicReferenceArray newHashChildren(int)
meth public java.util.concurrent.atomic.AtomicReferenceArray newLinearChildren(int)
meth public org.graalvm.collections.LockFreePrefixTree$Node newNode(long)
meth public void shutdown()
supr org.graalvm.collections.LockFreePrefixTree$Allocator
hfds DEFAULT_HOUSEKEEPING_PERIOD_MILLIS,EXPECTED_MAX_HASH_NODE_SIZE,FAILED_ALLOCATION_EXCEPTION,INITIAL_HASH_CHILDREN_PREALLOCATION_COUNT,INITIAL_LINEAR_CHILDREN_PREALLOCATION_COUNT,INITIAL_NODE_PREALLOCATION_COUNT,INTERNAL_FAILURE_EXCEPTION,LOGGING,MAX_CHILDREN_PREALLOCATION_COUNT,MAX_NODE_PREALLOCATION_COUNT,MIN_HOUSEKEEPING_PERIOD_MILLIS,SIZE_CLASS_COUNT,UNSUPPORTED_SIZE_EXCEPTION,hashChildrenPool,housekeepingThread,linearChildrenPool,missedHashChildrenRequestCounts,missedLinearChildrenRequestCounts,missedNodePoolRequestCount,nodePool
hcls HousekeepingThread

CLSS public abstract interface org.graalvm.collections.MapCursor<%0 extends java.lang.Object, %1 extends java.lang.Object>
intf org.graalvm.collections.UnmodifiableMapCursor<{org.graalvm.collections.MapCursor%0},{org.graalvm.collections.MapCursor%1}>
meth public abstract void remove()
meth public {org.graalvm.collections.MapCursor%1} setValue({org.graalvm.collections.MapCursor%1})

CLSS public final org.graalvm.collections.Pair<%0 extends java.lang.Object, %1 extends java.lang.Object>
meth public boolean equals(java.lang.Object)
meth public int hashCode()
meth public java.lang.String toString()
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.Pair<{%%0},{%%1}> create({%%0},{%%1})
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.Pair<{%%0},{%%1}> createLeft({%%0})
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.Pair<{%%0},{%%1}> createRight({%%1})
meth public static <%0 extends java.lang.Object, %1 extends java.lang.Object> org.graalvm.collections.Pair<{%%0},{%%1}> empty()
meth public {org.graalvm.collections.Pair%0} getLeft()
meth public {org.graalvm.collections.Pair%1} getRight()
supr java.lang.Object
hfds EMPTY,left,right

CLSS public org.graalvm.collections.SeqLockPrefixTree
cons public init()
innr public final static Node
meth public org.graalvm.collections.SeqLockPrefixTree$Node root()
supr java.lang.Object
hfds EMPTY_KEY,HASH_NODE_LOAD_FACTOR,INITIAL_HASH_NODE_SIZE,INITIAL_LINEAR_NODE_SIZE,MAX_LINEAR_NODE_SIZE,root
hcls Visitor

CLSS public final static org.graalvm.collections.SeqLockPrefixTree$Node
 outer org.graalvm.collections.SeqLockPrefixTree
meth public <%0 extends java.lang.Object> void topDown({%%0},java.util.function.BiFunction<{%%0},java.lang.Long,{%%0}>,java.util.function.BiConsumer<{%%0},java.lang.Long>)
meth public java.lang.String toString()
meth public long incValue()
meth public long seqlockValue()
meth public long value()
meth public org.graalvm.collections.SeqLockPrefixTree$Node at(long)
meth public void setValue(long)
supr java.util.concurrent.atomic.AtomicLong
hfds arity,children,keys,seqlock,serialVersionUID

CLSS public abstract interface org.graalvm.collections.UnmodifiableEconomicMap<%0 extends java.lang.Object, %1 extends java.lang.Object>
meth public abstract boolean containsKey({org.graalvm.collections.UnmodifiableEconomicMap%0})
meth public abstract boolean isEmpty()
meth public abstract int size()
meth public abstract java.lang.Iterable<{org.graalvm.collections.UnmodifiableEconomicMap%0}> getKeys()
meth public abstract java.lang.Iterable<{org.graalvm.collections.UnmodifiableEconomicMap%1}> getValues()
meth public abstract org.graalvm.collections.UnmodifiableMapCursor<{org.graalvm.collections.UnmodifiableEconomicMap%0},{org.graalvm.collections.UnmodifiableEconomicMap%1}> getEntries()
meth public abstract {org.graalvm.collections.UnmodifiableEconomicMap%1} get({org.graalvm.collections.UnmodifiableEconomicMap%0})
meth public org.graalvm.collections.Equivalence getEquivalenceStrategy()
meth public {org.graalvm.collections.UnmodifiableEconomicMap%1} get({org.graalvm.collections.UnmodifiableEconomicMap%0},{org.graalvm.collections.UnmodifiableEconomicMap%1})

CLSS public abstract interface org.graalvm.collections.UnmodifiableEconomicSet<%0 extends java.lang.Object>
intf java.lang.Iterable<{org.graalvm.collections.UnmodifiableEconomicSet%0}>
meth public abstract boolean contains({org.graalvm.collections.UnmodifiableEconomicSet%0})
meth public abstract boolean isEmpty()
meth public abstract int size()
meth public {org.graalvm.collections.UnmodifiableEconomicSet%0}[] toArray({org.graalvm.collections.UnmodifiableEconomicSet%0}[])

CLSS public abstract interface org.graalvm.collections.UnmodifiableMapCursor<%0 extends java.lang.Object, %1 extends java.lang.Object>
meth public abstract boolean advance()
meth public abstract {org.graalvm.collections.UnmodifiableMapCursor%0} getKey()
meth public abstract {org.graalvm.collections.UnmodifiableMapCursor%1} getValue()

