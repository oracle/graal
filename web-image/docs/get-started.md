---
layout: docs
title: Web Image
link_title: Web Image
permalink: /reference-manual/web-image/
toc_group: native-image
---

# Getting Started with Web Image

**Web Image** takes a JVM application, performs ahead-of-time (AOT) compilation using [GraalVM Native Image](../../docs/reference-manual/native-image/README.md), and produces a WebAssembly module together with a JavaScript runtime wrapper that can run in browsers or Node.js environments.
Web Image uses the standard GraalVM Native Image toolchain and is enabled by passing the `--tool:svm-wasm` option to the `native-image` tool.

> Note: Web Image is an experimental technology and under active development. APIs, tooling, and capabilities may change.

## Prerequisites

To build Web Image applications, you need:

* An [Early Access build](https://github.com/graalvm/oracle-graalvm-ea-builds/releases) of Oracle GraalVM 25 (25e1) or later.
* All [prerequisites](../../docs/reference-manual/native-image/README.md#prerequisites) required for Native Image building.
* [Binaryen toolchain](https://github.com/WebAssembly/binaryen) version 119 or later, available on the system path. Web Image uses `wasm-as` from `binaryen` as its assembler.
  * **macOS**: It is recommended to install Binaryen using Homebrew, as the pre-built binaries from GitHub may be quarantined by the operating system:
    ```bash
    brew install binaryen
    ```
  * **Other platforms**: Download a pre-built release for your platform from [GitHub](https://github.com/WebAssembly/binaryen/releases).

### Advantages

Web Image opens new use-cases for JVM ecosystem such as:

* Running JVM applications in browsers or on Wasm-enabled runtimes such as Node.js
* Producing portable artifacts that can run across multiple environments

### Current Status and Limitations

Web Image in GraalVM is early and experimental.
It is not yet part of the `native-image` tool in stable releases.
You need to run on [Early Access build of Oracle GraalVM 25e1 or later](https://github.com/graalvm/oracle-graalvm-ea-builds).

The WebAssembly code generated by Web Image makes use of various WebAssembly features from WebAssembly 3.0:

* [Garbage Collection](https://github.com/WebAssembly/gc)
* [Exception Handling](https://github.com/WebAssembly/exception-handling/blob/master/proposals/exception-handling/Exceptions.md)
* [Typed Function References](https://github.com/WebAssembly/function-references/blob/main/proposals/function-references/Overview.md)

Support for WebAssembly 2.0 is generally assumed.
At present, Web Image is best suited for application-style builds hosted by a JavaScript runtime.

## Usage

1. Create a simple Java application. Save the following code to _HelloWasm.java_:

    ```java
    public class HelloWasm {
        public static int add(int a, int b) {
            return a + b;
        }

        public static void main(String[] args) {
            System.out.println(add(3, 4));
        }
    }
    ```
2. Compile the Java source file:

    ```bash
    javac HelloWasm.java
    ```

3. Build an image. Use the `native-image` tool with the Web Image backend:

    ```bash
    native-image --tool:svm-wasm HelloWasm
    ```

    The `--tool:svm-wasm` option should be the first argument.
    If any options specific to the Wasm backend are used, they can only be added after this option.

  The build produces the following artifacts in your working directory:

  * _hellowasm.js_: a JavaScript launcher and runtime entry point;
  * _hellowasm.js.wasm_: the WebAssembly module compiled from JVM bytecode. It is not a standalone executable.
  * _hellowasm.js.wat_ debug artifacts to understand how JVM bytecode and runtime components are lowered to WebAssembly.

## Running the Application

**Option 1: Run with Node.js**

You cannot run _.wasm_ directly in Wasm runtimes because the generated module depends on JavaScript-provided imports and runtime.
Thus commands such as `wasmtime hellowasm.js.wasm` will not work in the current version.

Run the generated JavaScript wrapper with Node.js instead:
```bash
node --experimental-wasm-exnref hellowasm.js
```
You should see `7` as an output.
That is `main(String[])` executing, with `System.out` wired through JS.

> The `--experimental-wasm-exnref` option is required for Node.js versions prior to 25 to enable WebAssembly exception handling used by GraalVM.

**Option 2: Run in a browser**

You can also run the application in a browser using a simple HTTP server.
Browsers restrict loading Wasm modules from the local filesystem, so opening via `file://` will not work.

1. Create an _index.html_ file in the working directory:
    ```html
     <!DOCTYPE html>
     <html>
       <body>
         <script src="hellowasm.js"></script>
        <div>Hello from GraalVM Web Image!</div>
       </body>
     </html>
    ```
    Instead of just loading the script, you can attach some logic after the runtime is ready.

2. Start a local server using your Java or Python environment:
    ```bash
    jwebserver -p 8000
    ```
    ```bash
    python3 -m http.server 8000
    ```

3. Navigate to [http://localhost:8000](http://localhost:8000). When you open the page you will see the following in the browser console:
    ```
    Result of add(3, 4): 7
    ```

## Related Documentation

* To learn more, see how to [compile javac into a Wasm module](https://github.com/graalvm/graalvm-demos/tree/master/native-image/wasm-javac).
* Review a demo [showing builds of JVM applications (such as Spring Shell) running in JavaScript-hosted Wasm environments](https://github.com/graalvm/graalvm-demos/tree/master/native-image/wasm-spring-shell).
* See the [GraalVM Web Image API](https://www.graalvm.org/sdk/javadoc/org/graalvm/webimage/api/package-summary.html).