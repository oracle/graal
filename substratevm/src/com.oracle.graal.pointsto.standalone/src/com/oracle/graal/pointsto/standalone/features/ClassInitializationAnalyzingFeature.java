/*
 * Copyright (c) 2022, 2022, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2022, 2022, Alibaba Group Holding Limited. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.oracle.graal.pointsto.standalone.features;

import com.oracle.graal.pointsto.meta.AnalysisMethod;
import com.oracle.graal.pointsto.standalone.StandaloneOptions;
import com.oracle.graal.pointsto.standalone.classinitialization.KnownSafeMethodRegistration;
import com.oracle.graal.pointsto.standalone.classinitialization.StandaloneTypeInitializerGraph;
import com.oracle.graal.pointsto.util.AnalysisError;
import org.graalvm.compiler.options.Option;
import org.graalvm.compiler.options.OptionKey;
import org.graalvm.compiler.options.OptionType;
import org.graalvm.compiler.options.OptionValues;
import org.graalvm.nativeimage.hosted.Feature;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

/**
 * This class does the eager class initialization analysis for all reachable classes. This analysis
 * is disabled by default, and can be enabled by setting
 * {@code -H:+EnableClassInitializationAnalyze} option. The analysis result is stored in a
 * {@code Map<String, Optional<String>} where the key is class name and the value is the unsafe
 * reason. An empty reason means the class is safe to be eagerly initialized.
 *
 * There are two approaches to obtain the analysis result:
 * <ol>
 * <li>By calling
 * {@link com.oracle.graal.pointsto.standalone.PointsToAnalyzer#getResultFromFeature(Class)} API:
 * call {@code getResultFromFeature} method to get the analysis result and use it in your own
 * program. Code example:
 * 
 * <pre>
 *     {@code
 *     // arguments is the String array of pointsto analysis options
 *     PointsToAnalyzer pointsToAnalyzer = PointsToAnalyzer.createAnalyzer(arguments);
 *     // run the pointsto analysis
 *     pointsToAnalyzer.run()
 *     // get the result generated by ClassInitializationAnalyzingFeature
 *     Map<String, Optional<String>> result = (Map<String, Optional<String>>)pointsToAnalyzer.getResultFromFeature(ClassInitializationAnalyzingFeature.class);
 *     }
 * </pre>
 * 
 * </li>
 * <li>By printing out to a file: The result can be printed out to a file with
 * {@code -H:PrintClassEagerInitResult=report/path/file.name} option. The report firstly shows the
 * safe classes, then the unsafe classes and their reasons, and finally a summary.</li>
 * </ol>
 *
 * This class is tested by {@code com.oracle.graal.pointsto.test.ClassInitializationTimingTest}.
 */
public class ClassInitializationAnalyzingFeature implements Feature {

    public static class Options {
        @Option(help = "Print the eager class initialization analysis result to the specified file.", type = OptionType.Debug)
//
        public static final OptionKey<String> PrintClassEagerInitResult = new OptionKey<>(null);

        @Option(help = "file:doc-files/knownSafeMethodsFileHelp.txt", type = OptionType.User)
//
        public static final OptionKey<String> KnownSafeMethodsList = new OptionKey<>(null);
    }

    @Override
    public void onAnalysisExit(OnAnalysisExitAccess access) {
        Map<String, Optional<String>> result = new HashMap<>();
        StandaloneAnalysisFeatureImpl.OnAnalysisExitAccessImpl a = (StandaloneAnalysisFeatureImpl.OnAnalysisExitAccessImpl) access;
        OptionValues options = a.bb.getOptions();

        Set<AnalysisMethod> knownSafeMethods = KnownSafeMethodRegistration.getInstance().registerConfiguredMethods(Options.KnownSafeMethodsList.getValue(options), a.bb, a.analysisClassLoader);
        StandaloneTypeInitializerGraph initGraph = new StandaloneTypeInitializerGraph(a.getUniverse(), knownSafeMethods);
        initGraph.computeInitializerSafety();
        initGraph.getUnsafeTypeReasons().forEach((k, v) -> result.put(k.toJavaName(true), v.getRight()));
        a.setAnalysisResult(this.getClass(), result);
        printReport(result, options);
    }

    private static void printReport(Map<String, Optional<String>> result, OptionValues options) {
        String printResultOptionValue = Options.PrintClassEagerInitResult.getValue(options);
        if (printResultOptionValue != null && printResultOptionValue.length() > 0) {
            Path resultPath = StandaloneOptions.reportsPath(options, "reports").resolve(printResultOptionValue);
            if (Files.notExists(resultPath)) {
                try {
                    Path parentDirPath = resultPath.getParent();
                    if (parentDirPath == null) {
                        AnalysisError.shouldNotReachHere("Can't create the parent directory for " + resultPath);
                    } else {
                        Files.createDirectories(parentDirPath);
                    }
                } catch (IOException e) {
                    AnalysisError.shouldNotReachHere(e);
                }
            }
            try (FileWriter fileWriter = new FileWriter(resultPath.toFile());
                            PrintWriter printWriter = new PrintWriter(fileWriter)) {
                result.entrySet().stream().sorted((o1, o2) -> {
                    if (o1.getValue().isPresent() == o2.getValue().isPresent()) {
                        return o1.getKey().compareTo(o2.getKey());
                    } else {
                        if (o1.getValue().isEmpty() || o2.getValue().isPresent()) {
                            return -1;
                        } else {
                            return 1;
                        }
                    }
                }).forEach(entry -> printWriter.println(String.format("%s    %s", entry.getKey(), entry.getValue().map(s -> "Unsafe. Reason: " + s).orElse("Safe"))));
                long totalUnsafe = 0;
                long totalSafe = 0;
                for (Optional<String> value : result.values()) {
                    if (value.isPresent()) {
                        totalUnsafe++;
                    } else {
                        totalSafe++;
                    }
                }
                printWriter.println("===================================");
                printWriter.println("Summary:");
                printWriter.println("The total unsafe classes: " + totalUnsafe);
                printWriter.println("The total safe classes: " + totalSafe);
            } catch (IOException e) {
                AnalysisError.shouldNotReachHere(e);
            }
            System.out.println("Class eager initialization report is printed to " + resultPath.normalize().toAbsolutePath().toString());
        }
    }
}
