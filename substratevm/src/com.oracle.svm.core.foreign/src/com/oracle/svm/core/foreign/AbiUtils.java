/*
 * Copyright (c) 2023, 2023, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.oracle.svm.core.foreign;

import static com.oracle.svm.core.util.VMError.unsupportedFeature;

import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodType;
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Stream;

import org.graalvm.compiler.api.replacements.Fold;
import org.graalvm.compiler.nodes.ValueNode;
import org.graalvm.compiler.nodes.calc.ReinterpretNode;
import org.graalvm.nativeimage.ImageSingletons;
import org.graalvm.nativeimage.Platform;
import org.graalvm.nativeimage.Platforms;

import com.oracle.svm.core.SubstrateTargetDescription;
import com.oracle.svm.core.SubstrateUtil;
import com.oracle.svm.core.graal.code.AssignedLocation;
import com.oracle.svm.core.headers.LibC;
import com.oracle.svm.core.headers.WindowsAPIs;
import com.oracle.svm.core.util.VMError;

import jdk.internal.foreign.CABI;
import jdk.internal.foreign.abi.Binding;
import jdk.internal.foreign.abi.CallingSequence;
import jdk.internal.foreign.abi.LinkerOptions;
import jdk.internal.foreign.abi.VMStorage;
import jdk.internal.foreign.abi.x64.X86_64Architecture;
import jdk.vm.ci.amd64.AMD64;
import jdk.vm.ci.code.Register;
import jdk.vm.ci.meta.JavaKind;
import jdk.vm.ci.meta.PlatformKind;

/**
 * Utils for ABI specific functionalities in the context of the Java Foreign API. Provides methods
 * to transform JDK-internal data-structures into SubstrateVM ones.
 */
public abstract class AbiUtils {

    @Platforms(Platform.HOSTED_ONLY.class)
    public abstract static class Adaptation {
        public abstract Class<?> apply(Class<?> parameter);

        public abstract ValueNode apply(ValueNode parameter);
    }

    @Platforms(Platform.HOSTED_ONLY.class)
    public static final class Reinterpret extends Adaptation {
        public final JavaKind to;

        public Reinterpret(JavaKind to) {
            this.to = to;
        }

        @Override
        public Class<?> apply(Class<?> parameter) {
            return to.toJavaClass();
        }

        @Override
        public ValueNode apply(ValueNode parameter) {
            return ReinterpretNode.reinterpret(to, parameter);
        }
    }

    @Platforms(Platform.HOSTED_ONLY.class)
    public static AbiUtils create() {
        return switch (CABI.current()) {
            case SYS_V -> new ABIs.SysV();
            case WIN_64 -> new ABIs.Win64();
            default -> new ABIs.Unsupported(CABI.current().name());
        };
    }

    @Fold
    public static AbiUtils singleton() {
        return ImageSingletons.lookup(AbiUtils.class);
    }

    public abstract void methodTypeMatchAssignment(int savedValueMask, MethodType methodType, AssignedLocation[] assignments, AssignedLocation[] returnAssignment, FunctionDescriptor fd,
                    Linker.Option... options);

    /**
     * This method re-implements a part of the logic from the JDK so that we can get the callee-type
     * (i.e. the ABI low-level type) of a function from its descriptor.
     */
    public abstract NativeEntryPointInfo makeEntrypoint(FunctionDescriptor desc, Linker.Option... options);

    /**
     * Generate a register allocation for SubstrateVM from the one generated by and for HotSpot.
     */
    public abstract AssignedLocation[] toMemoryAssignment(VMStorage[] moves, boolean forReturn);

    /**
     * Generate additional argument adaptations which are not done by HotSpot. Note that, unlike
     * {@link AbiUtils#toMemoryAssignment}, this information is not part of
     * {@link NativeEntryPointInfo}. The reason for that being that this information is not relevant
     * at runtime, so we don't want ot include it in {@link NativeEntryPointInfo}, which lives at
     * runtime. This information is only useful when generating the
     * {@link com.oracle.svm.hosted.foreign.DowncallStub}.
     * <p>
     * For convenience, there is an adaptation for every argument (except the NEP itself) to the
     * entrypoint, i.e. including the special prefix arguments (call address, return buffer, call
     * state buffer), even though these should most likely never be adapted.
     */
    @Platforms(Platform.HOSTED_ONLY.class)
    public abstract Adaptation[] adaptArguments(NativeEntryPointInfo nep);

    @Platforms(Platform.HOSTED_ONLY.class)
    public abstract void checkLibrarySupport();

    /**
     * Backport the {@link Linker} method of the same name introduced in JDK22. TODO: replace by
     * said method once possible
     */
    @Platforms(Platform.HOSTED_ONLY.class)
    public abstract Map<String, MemoryLayout> canonicalLayouts();
}

class ABIs {
    static final class Unsupported extends AbiUtils {
        private final String name;

        Unsupported(String name) {
            this.name = name;
        }

        private <Z> Z fail() {
            throw unsupportedFeature(name());
        }

        private String name() {
            return "Unsupported ABI: " + name;
        }

        @Override
        public void methodTypeMatchAssignment(int savedValueMask, MethodType methodType, AssignedLocation[] assignments, AssignedLocation[] returnAssignment, FunctionDescriptor fd,
                        Linker.Option... options) {
            fail();
        }

        @Override
        public NativeEntryPointInfo makeEntrypoint(FunctionDescriptor desc, Linker.Option... options) {
            return fail();
        }

        @Override
        public AssignedLocation[] toMemoryAssignment(VMStorage[] moves, boolean forReturn) {
            return fail();
        }

        @Override
        public Adaptation[] adaptArguments(NativeEntryPointInfo nep) {
            return fail();
        }

        @Override
        public void checkLibrarySupport() {
            fail();
        }

        @Override
        public Map<String, MemoryLayout> canonicalLayouts() {
            return fail();
        }
    }

    private abstract static class X86_64 extends AbiUtils {
        protected static Stream<Binding.VMStore> argMoveBindingsStream(CallingSequence callingSequence) {
            return callingSequence.argumentBindings()
                            .filter(Binding.VMStore.class::isInstance)
                            .map(Binding.VMStore.class::cast);
        }

        protected static Stream<Binding.VMLoad> retMoveBindingsStream(CallingSequence callingSequence) {
            return callingSequence.returnBindings().stream()
                            .filter(Binding.VMLoad.class::isInstance)
                            .map(Binding.VMLoad.class::cast);
        }

        protected static Binding.VMLoad[] retMoveBindings(CallingSequence callingSequence) {
            return retMoveBindingsStream(callingSequence).toArray(Binding.VMLoad[]::new);
        }

        protected VMStorage[] toStorageArray(Binding.Move[] moves) {
            return Arrays.stream(moves).map(Binding.Move::storage).toArray(VMStorage[]::new);
        }

        protected abstract CallingSequence makeCallingSequence(MethodType type, FunctionDescriptor desc, boolean forUpcall, LinkerOptions options);

        protected boolean typeMatchRegister(AMD64 target, Class<?> type, Register register, boolean isVararg) {
            Register.RegisterCategory rc = register.getRegisterCategory();
            PlatformKind kind = target.getPlatformKind(JavaKind.fromJavaClass(type));
            return target.canStoreValue(rc, kind);
        }

        @Override
        public void methodTypeMatchAssignment(int savedValueMask, MethodType methodType, AssignedLocation[] assignments, AssignedLocation[] returnAssignment, FunctionDescriptor fd,
                        Linker.Option... options) {
            if (!SubstrateUtil.assertionsEnabled()) {
                return;
            }

            int firstActualArgument = 0;
            if (methodType.parameterType(firstActualArgument++) != long.class) {
                throw new AssertionError("Address expected as first param: " + methodType);
            }
            if (returnAssignment != null && methodType.parameterType(firstActualArgument++) != long.class) {
                throw new AssertionError("Return buffer address expected: " + methodType);
            }
            if (savedValueMask != 0 && methodType.parameterType(firstActualArgument++) != long.class) {
                throw new AssertionError("Capture buffer address expected: " + methodType);
            }

            /*
             * This assertion can fail if, the entrypoint is supposed to capture the call state, but
             * the provided mask is 0, i.e. a capture call state option is provided but with an
             * empty capture list.
             */
            /*
             * TODO: check for capture more uniformly; either always rely on the presence of the
             * option (even if empty), or on the non-zeroness of the mask. Note that part of this
             * mismatch might also be coming from JDK code, in which case we cannot do much.
             */
            assert firstActualArgument + assignments.length == methodType.parameterCount() : assignments.length + " " + methodType.parameterCount();
            AMD64 target = (AMD64) ImageSingletons.lookup(SubstrateTargetDescription.class).arch;
            LinkerOptions optionsSet = LinkerOptions.forDowncall(fd, options);

            for (int i = 0; i < assignments.length; ++i) {
                var type = methodType.parameterType(firstActualArgument + i);
                var assignment = assignments[i];
                assert !assignment.assignsToRegister() ||
                                typeMatchRegister(target, type, assignment.register(),
                                                optionsSet.isVarargsIndex(i)) : "Cannot put %s in %s.\nDescriptor & options: %s %s\nAssignment: %s\nMethod type (placeholders: %d): %s"
                                                                .formatted(type, assignment.register(), fd, Arrays.toString(options), Arrays.toString(assignments), firstActualArgument, methodType);
            }

            assert returnAssignment == null || methodType.returnType().equals(void.class);
        }

        @Override
        public NativeEntryPointInfo makeEntrypoint(FunctionDescriptor desc, Linker.Option... options) {
            // Linker.downcallHandle implemented in
            // AbstractLinker.downcallHandle

            // AbstractLinker.downcallHandle0
            LinkerOptions optionSet = LinkerOptions.forDowncall(desc, options);
            MethodType type = desc.toMethodType();

            /* OS SPECIFIC BEGINS */
            // AbstractLinker.arrangeDowncall implemented in
            // SysVx64Linker.arrangeDowncall or Windowsx64Linker.arrangeDowncall

            // CallArranger.arrangeDowncall
            var callingSequence = makeCallingSequence(type, desc, false, optionSet);
            /* OS SPECIFIC ENDS */

            // DowncallLinker.getBoundMethodHandle
            var argMoves = toStorageArray(argMoveBindingsStream(callingSequence).toArray(Binding.VMStore[]::new));
            var returnMoves = toStorageArray(retMoveBindings(callingSequence));
            var boundaryType = callingSequence.calleeMethodType();
            var needsReturnBuffer = callingSequence.needsReturnBuffer();

            // NativeEntrypoint.make
            var parametersAssignment = toMemoryAssignment(argMoves, false);
            var returnBuffering = needsReturnBuffer ? toMemoryAssignment(returnMoves, true) : null;
            AbiUtils.singleton().methodTypeMatchAssignment(callingSequence.capturedStateMask(), boundaryType, parametersAssignment, returnBuffering, desc, options);
            return NativeEntryPointInfo.make(argMoves, returnMoves, boundaryType, needsReturnBuffer, callingSequence.capturedStateMask(), callingSequence.needsTransition());
        }

        @Override
        public AssignedLocation[] toMemoryAssignment(VMStorage[] argMoves, boolean forReturn) {
            int size = 0;
            for (VMStorage move : argMoves) {
                if (move.type() != X86_64Architecture.StorageType.PLACEHOLDER) {
                    // Placeholders are ignored; they will be handled further down the line
                    ++size;
                } else {
                    // Placeholders are expected to be prefix arguments
                    assert size == 0 : "Placeholders are expected to be prefix arguments";
                }

                if (move.type() == X86_64Architecture.StorageType.X87) {
                    throw unsupportedFeature("Unsupported register kind: X87");
                } else if (move.type() == X86_64Architecture.StorageType.STACK && forReturn) {
                    throw unsupportedFeature("Unsupported register kind for return: STACK");
                }
            }

            AssignedLocation[] storages = new AssignedLocation[size];
            int i = 0;
            for (VMStorage move : argMoves) {
                if (move.type() != X86_64Architecture.StorageType.PLACEHOLDER) {
                    storages[i++] = switch (move.type()) {
                        case X86_64Architecture.StorageType.INTEGER -> {
                            Register reg = AMD64.cpuRegisters[move.indexOrOffset()];
                            assert reg.name.equals(move.debugName());
                            assert reg.getRegisterCategory().equals(AMD64.CPU);
                            yield AssignedLocation.forRegister(reg);
                        }
                        case X86_64Architecture.StorageType.VECTOR -> {
                            /*
                             * Only the first four xmm registers should ever be used; in particular,
                             * this means we never need to index in xmmRegistersAVX512
                             */
                            Register reg = AMD64.xmmRegistersSSE[move.indexOrOffset()];
                            assert reg.name.equals(move.debugName());
                            assert reg.getRegisterCategory().equals(AMD64.XMM);
                            yield AssignedLocation.forRegister(reg);
                        }
                        case X86_64Architecture.StorageType.STACK -> AssignedLocation.forStack(move.indexOrOffset());
                        default -> throw unsupportedFeature("Unhandled VMStorage: " + move);
                    };
                }
            }
            assert i == storages.length;

            return storages;
        }

        protected static Map<String, MemoryLayout> canonicalLayouts(ValueLayout longLayout, ValueLayout sizetLayout, ValueLayout wchartLayout) {
            return Map.ofEntries(
                            // specified canonical layouts
                            Map.entry("bool", ValueLayout.JAVA_BOOLEAN),
                            Map.entry("char", ValueLayout.JAVA_BYTE),
                            Map.entry("short", ValueLayout.JAVA_SHORT),
                            Map.entry("int", ValueLayout.JAVA_INT),
                            Map.entry("float", ValueLayout.JAVA_FLOAT),
                            Map.entry("long", longLayout),
                            Map.entry("long long", ValueLayout.JAVA_LONG),
                            Map.entry("double", ValueLayout.JAVA_DOUBLE),
                            Map.entry("void*", ValueLayout.ADDRESS),
                            Map.entry("size_t", sizetLayout),
                            Map.entry("wchar_t", wchartLayout),
                            // unspecified size-dependent layouts
                            Map.entry("int8_t", ValueLayout.JAVA_BYTE),
                            Map.entry("int16_t", ValueLayout.JAVA_SHORT),
                            Map.entry("int32_t", ValueLayout.JAVA_INT),
                            Map.entry("int64_t", ValueLayout.JAVA_LONG),
                            // unspecified JNI layouts
                            Map.entry("jboolean", ValueLayout.JAVA_BOOLEAN),
                            Map.entry("jchar", ValueLayout.JAVA_CHAR),
                            Map.entry("jbyte", ValueLayout.JAVA_BYTE),
                            Map.entry("jshort", ValueLayout.JAVA_SHORT),
                            Map.entry("jint", ValueLayout.JAVA_INT),
                            Map.entry("jlong", ValueLayout.JAVA_LONG),
                            Map.entry("jfloat", ValueLayout.JAVA_FLOAT),
                            Map.entry("jdouble", ValueLayout.JAVA_DOUBLE));
        }
    }

    static final class SysV extends X86_64 {
        @Override
        protected CallingSequence makeCallingSequence(MethodType type, FunctionDescriptor desc, boolean forUpcall, LinkerOptions options) {
            return jdk.internal.foreign.abi.x64.sysv.CallArranger.getBindings(type, desc, forUpcall, options).callingSequence();
        }

        @Override
        @Platforms(Platform.HOSTED_ONLY.class)
        public Adaptation[] adaptArguments(NativeEntryPointInfo nep) {
            // No adaptations needed
            return new Adaptation[nep.linkMethodType().parameterCount()];
        }

        @Override
        @Platforms(Platform.HOSTED_ONLY.class)
        public void checkLibrarySupport() {
            String name = "SystemV (Linux AMD64)";
            VMError.guarantee(LibC.isSupported(), "Foreign functions feature requires LibC support on " + name);
        }

        @Override
        public Map<String, MemoryLayout> canonicalLayouts() {
            return canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);
        }
    };

    static final class Win64 extends X86_64 {
        @Override
        protected CallingSequence makeCallingSequence(MethodType type, FunctionDescriptor desc, boolean forUpcall, LinkerOptions options) {
            return jdk.internal.foreign.abi.x64.windows.CallArranger.getBindings(type, desc, forUpcall, options).callingSequence();
        }

        @Override
        protected boolean typeMatchRegister(AMD64 target, Class<?> type, Register register, boolean isVararg) {
            Register.RegisterCategory rc = register.getRegisterCategory();
            JavaKind kind = JavaKind.fromJavaClass(type);
            PlatformKind platformKind = target.getPlatformKind(kind);
            return target.canStoreValue(rc, platformKind) || (isVararg &&
                            register.getRegisterCategory().equals(AMD64.CPU) && (kind.equals(JavaKind.Float) || kind.equals(JavaKind.Double)));
        }

        /**
         * The Win64 ABI allows one mismatch between register and value type: When a variadic
         * floating-point argument is among the first four parameters of the function, the argument
         * should be passed in both the XMM and CPU register.
         *
         * This method is slightly cheating: technically, we only ever want to adapt the
         * cpu-register-assigned copy of a "register assigned floating point vararg parameter" from
         * floating-point to long. This method assumes that this case will be the only source
         * assignments of float/double parameters to a cpu register.
         */
        @Override
        @Platforms(Platform.HOSTED_ONLY.class)
        public Adaptation[] adaptArguments(NativeEntryPointInfo nep) {
            /*
             * This method also performs some sanity checks about the generated entrypoint.
             */
            MethodType methodType = nep.linkMethodType();
            AssignedLocation[] assignments = nep.parametersAssignment();

            int firstActualArgument = 0;
            // Note that the following ifs do increment firstActualArgument !
            if (methodType.parameterType(firstActualArgument++) != long.class && SubstrateUtil.assertionsEnabled()) {
                throw new AssertionError("Address expected as first param: " + methodType);
            }
            if (nep.returnsAssignment() != null && methodType.parameterType(firstActualArgument++) != long.class && SubstrateUtil.assertionsEnabled()) {
                throw new AssertionError("Return buffer address expected: " + methodType);
            }
            if (nep.capturesCallState() && methodType.parameterType(firstActualArgument++) != long.class && SubstrateUtil.assertionsEnabled()) {
                throw new AssertionError("Capture buffer address expected: " + methodType);
            }

            assert firstActualArgument + assignments.length == methodType.parameterCount() : assignments.length + " " + methodType.parameterCount();
            AMD64 target = (AMD64) ImageSingletons.lookup(SubstrateTargetDescription.class).arch;
            Adaptation[] adaptations = new Adaptation[methodType.parameterCount()];

            for (int i = firstActualArgument; i < adaptations.length; ++i) {
                Class<?> type = methodType.parameterType(i);
                AssignedLocation assignment = assignments[i - firstActualArgument];

                if (assignment.assignsToRegister()) {
                    Register.RegisterCategory rc = assignment.register().getRegisterCategory();
                    PlatformKind kind = target.getPlatformKind(JavaKind.fromJavaClass(type));
                    if (!(target.canStoreValue(rc, kind))) {
                        assert rc.equals(AMD64.CPU) && (kind.equals(target.getPlatformKind(JavaKind.Float)) || kind.equals(target.getPlatformKind(JavaKind.Double)));
                        adaptations[i] = new Reinterpret(JavaKind.Long);
                    }
                }
            }

            return adaptations;
        }

        @Override
        @Platforms(Platform.HOSTED_ONLY.class)
        public void checkLibrarySupport() {
            String name = "Win64 (Windows AMD64)";
            VMError.guarantee(LibC.isSupported(), "Foreign functions feature requires LibC support on" + name);
            VMError.guarantee(WindowsAPIs.isSupported(), "Foreign functions feature requires Windows APIs support on" + name);
        }

        @Override
        public Map<String, MemoryLayout> canonicalLayouts() {
            return canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);
        }
    };
}
