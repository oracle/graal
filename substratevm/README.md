# Substrate VM

## Introduction

Substrate VM is a framework that allows ahead-of-time (AOT) compilation of Java applications under closed-world assumption into executable images or shared objects (ELF-64 or 64-bit Mach-O).


## Quick start

Install [mx](https://github.com/graalvm/mx) and point `JAVA_HOME` to a [labsjdk](http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html).

For compilation `native-image` depends on the local toolchain, so make sure: `glibc-devel`, `zlib-devel` (header files for the C library and `zlib`) and `gcc` are available on your system.

After cloning the repository, run

```bash
cd substratevm
mx build

echo "public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World\"); } }" > HelloWorld.java
$JAVA_HOME/bin/javac HelloWorld.java
mx native-image HelloWorld
./helloworld
```

## Build Script

Using Substrate VM requires the mx tool to be installed first, so that it is on your path.
Visit the [MX Homepage](https://github.com/graalvm/mx) for more details.

Substrate VM requires a JDK 8 with JVMCI. It is available from [OTN](http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html).

In the main directory, invoke `mx help` to see the list of commands. Most of the commands are inherited from the Graal and Truffle code bases. The most important commands for the Substrate VM are listed below. More information on the parameters of a command is available by running `mx help <command>`

* `build`: Compile all Java and native code.
* `clean`: Remove all compilation artifacts.
* `ideinit`: Create project files for Eclipse and other common IDEs. See the [documentation on IDE integration](../compiler/docs/IDEs.md) for details.

## Building images

After running `mx build` you can use `mx native-image` to build native images. You can specify the main entry point, i.e., the application you want to create the image for. For more information run `mx native-image --help`.

Native image generation is performed by a Java program that runs on JDK 8 with JVMCI. You can debug it with a regular Java debugger. Use `mx native-image --debug-attach` to start native image generation so that it waits for a Java debugger to attach first (by default, at port 8000). In Eclipse, use the debugging configuration "substratevm-localhost-8000" to attach to it. This debugging configuration is automatically generated by `mx ideinit`.

If you find yourself having to debug into the Graal level of SubstrateVM, you should read the Graal [debugging](../compiler/docs/Debugging.md) page. You can use Ideal Graph Visualizer to view individual compilation steps:
```bash
mx igv &>/dev/null &
mx native-image HelloWorld -H:Dump= -H:MethodFilter=HelloWorld.*
```

## Images and Entry Points

An SVM image can be built as a standalone executable, which is the default, or as a shared library by passing `--shared` to `native-image`. For an image to be useful, it needs to have at least one entry point method.

For executables, SVM supports Java main methods with a signature that takes the command-line arguments as an array of strings:

```java
public static void main(String[] arg) { /* ... */ }
```

For shared libraries, SVM provides the `@CEntryPoint` annotation to specify entry point methods that should be exported and callable from C. Entry point methods must be static and may only have non-object parameters and return types â€“ this includes Java primitives, but also Word types (including pointers). 
One of the parameters of an entry point method has to be of type `IsolateThread` or `Isolate`.
This parameter provides the current thread's execution context for the call. For example:

```java
@CEntryPoint static int add(IsolateThread thread, int a, int b) {
    return a + b;
}
```

Shared library builds generate an additional C header file. This header file contains declarations for the [SVM C API](C-API.md), which allows creating isolates and attaching threads from C code, as well as declarations for each entry point in user code. The generated C declaration for the above example is:
```c
int add(graal_isolatethread_t* thread, int a, int b);
```

Both executable images and shared library images can have an arbitrary number of entry points, for example to implement callbacks or APIs.

## Options

More information about options, and the important distinction between hosted and runtime options, is available [here](OPTIONS.md).

## Project Structure

The list of projects is defined in a custom format in the file `mx.substratevm/suite.py`. It is never necessary to create new projects in the IDE. Instead, a new project is created by adding it in `suite.py` and running `mx ideinit` to generate a corresponding IDE project.

## Code Formatting

Style rules and procedures for checking adherence are described in the [style guide](STYLE.md).

## Troubleshooting Eclipse

Sometimes, Eclipse gives strange error messages, especially after pulling a bigger changeset. Also, projects are frequently added or removed, leading to error messages about missing projects if you do not import the new projects. The following should reset everything:

* Delete all projects in Eclipse
* `mx clean`
* `mx ideclean`
* `mx fsckprojects`
* `mx build`
* `mx ideinit`
* Import all projects into Eclipse again

## License

The Substrate VM is licensed under the [GPL 2 with Classpath exception](LICENSE.md).
